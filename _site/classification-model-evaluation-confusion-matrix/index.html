<!DOCTYPE html>
<html id="J-html" class="">
<head>
     <!--
     **
     * Author:         掌心
     * Contact:        zhanxin.info@gmail.com
     * Theme Name:     iLotus
     **
    -->
    <meta charset="UTF-8" />
    <title>
        
            分类器评价与在R中的实现：混淆矩阵
        
    </title>
    <meta name="generator" content="Jekyll" />
    <meta name="author" content="CCM" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" type="text/css" media="all" href="http://localhost:4000/static/style.css" />
    <!--[if lt IE 9]>
    <script src="http://localhost:4000/static/js/html5.js" type="text/javascript"></script>
    <![endif]-->
    <script src="http://localhost:4000/static/js/jquery.js" type="text/javascript"></script>
</head>
<body itemscope itemtype="http://schema.org/WebPage" class="home blog lotus index">
    <nav class="lotus-nav">
        <ul>
            
            
            
            
            
                
            
            <li class="home ">
                <a href="/index.html" rel="bookmark" title="首页">
                    <i class="icon-home"></i>
                </a>
                
            </li>
            
            
            
            
            
            <li class="">
                <a href="/archives.html" rel="bookmark" title="文章归档">
                    <i class="icon-reorder"></i>
                </a>
                
            </li>
            
            
            
            
            
            <li class="">
                <a href="/contact.html" rel="bookmark" title="关于我">
                    <i class="icon-envelope-alt"></i>
                </a>
                
            </li>
            
        </ul>
    </nav>

    <p class="lotus-breadcrub">
    <a href="http://localhost:4000/index.html" rel="nofollow" rel="nofollow" title="首页">Home</a>
    <span> &gt; </span>
    <a href="http://localhost:4000/archives.html" rel="nofollow" >Archives</a>
    <span> &gt; </span>
    分类器评价与在R中的实现：混淆矩阵
</p>
<h1 class="lotus-pagetit">分类器评价与在R中的实现：混淆矩阵</h1>
<p class="lotus-meta">Publish: <time class="date" pubdate="January 18, 2014">January 18, 2014</time></p>
<article  itemscope itemtype="http://schema.org/Article" class="lotus-post">
<p>分类模型评价一般有以下几种方法：混淆矩阵(Confusion Matrix)、收益图(Gain Chart)、提升图(Lift Chart)、KS图(KS Chart)、接受者操作特性曲线(ROC Chart)。“<a href="http://iccm.cc/?s=分类器评价与在R中的实现" target="_blank">分类模型评价与在R中的实现</a>”系列中将逐个介绍。</p>

<p>本篇介绍最基础的混淆矩阵。</p>

<!--more-->

<h1 id="section">一、混淆矩阵简介</h1>

<p>混淆矩阵将分类预测结果与实际目标进行比较，并汇总成NXN列联表（N为分类类型数）。</p>

<p>以二元分类为例：</p>

<table style="width:100%; " class="easy-table easy-table-default " border="0">
  <tr>
    &lt;td  colspan="2"&gt;Confusion Matrix <td>
    </td>
    
    <td colspan="2">
      Target
    </td>
    
    <td>
    </td>
  </tr>
  
  <tr>
    <td>
    </td>
    
    <td>
    </td>
    
    <td>
      Positive
    </td>
    
    <td>
      Negative
    </td>
  </tr>
  
  <tr>
    <td rowspan="2">
      Model
    </td>
    
    <td>
      Positive
    </td>
    
    <td>
      True Positives(TP)
    </td>
    
    <td>
      False Positives(FP)
    </td>
  </tr>
  
  <tr>
    <td>
      Negative
    </td>
    
    <td>
      False Negatives(FN)
    </td>
    
    <td>
      True Negatives(TN)
    </td>
  </tr>
  
  <tr>
    <td>
    </td>
    
    <td>
    </td>
    
    <td>
      Positive Samples(P)
    </td>
    
    <td>
      Negative Samples(N)
    </td>
  </tr>
</table>

<p>由上表可以计算的指标有：<br />
Accuracy = (TP+TN)/(P+N)<br />
Error Rate = 1 – Accuracy = (FP+FN)/(P+N)<br />
False Positive Rate = Fallout = FP/N<br />
True Positive Rate = Recall = Sensitivity = TP/P<br />
False Negative Rate = Miss = FN/P<br />
True Negative Rate = Specificity = TN/N<br />
Positive Predictive Value = Precision = TP/(TP+FP)<br />
Negative Predictive Value = TN/(TN+FN)<br />
Prediction-conditioned Fallout = FP/(TP+FP)<br />
Prediction-conditioned Miss = FN/(TN+FN)<br />
Rate of Positive Predictions = Detection Prevalence = (TP+FP)/(P+N)<br />
Rate of Negative Predictions = (TN+FN)/(P+N)<br />
Prevalence = (TP+FN)/(P+N)<br />
Detection Rate = TP/(P+N)<br />
Balanced Accuracy = (Sensitivity+Specificity)/2</p>

<p>是不是感觉这些货已经组合完所有的分子/分母了？没关系，其实只要知道TP和TN越高越好就好了。</p>

<h1 id="r">二、在R中计算混淆矩阵</h1>

<p>这次使用ROCR包中的ROCR.simple数据集，其中prediction是预测值，labels为真实值。</p>

<pre><code class="r">require(ROCR)
data(ROCR.simple)
str(ROCR.simple)
</code></pre>

<pre><code>## List of 2
##  $ predictions: num [1:200] 0.613 0.364 0.432 0.14 0.385 ...
##  $ labels     : num [1:200] 1 1 0 0 0 1 1 1 1 0 ...
</code></pre>

<h2 id="table">1 用table()直接计算</h2>

<p>在确定好阀值后，可以直接用table函数计算列联表，再根据之前的公式计算各个指标。假设我们认为prediciton&gt;0.5的都预测为1，其余为0.</p>

<pre><code class="r">pred.class &lt;- as.integer(ROCR.simple$predictions &gt; 0.5)
print(cft &lt;- table(pred.class, ROCR.simple$labels))
</code></pre>

<pre><code>##           
## pred.class  0  1
##          0 91 14
##          1 16 79
</code></pre>

<p>通过对混淆矩阵中数值的计算可以得到：</p>

<pre><code class="r">tp &lt;- cft[2, 2]
tn &lt;- cft[1, 1]
fp &lt;- cft[2, 1]
fn &lt;- cft[1, 2]
print(accuracy &lt;- (tp + tn)/(tp + tn + fp + fn))
</code></pre>

<pre><code>## [1] 0.85
</code></pre>

<pre><code class="r">print(sensitivity &lt;- tp/(tp + fn))
</code></pre>

<pre><code>## [1] 0.8495
</code></pre>

<pre><code class="r">print(specificity &lt;- tn/(tn + fp))
</code></pre>

<pre><code>## [1] 0.8505
</code></pre>

<h2 id="confusionmatrix">2 用confusionMatrix()算</h2>

<p>如果不想手动算，可以借助caret包中的confusionMatrix函数计算。该函数既可以用混淆矩阵的结果，也可以直接输入预测/目标两列原始数据计算上述值。只要确定好positive分类是那个，就能得出跟之前一样的结果。</p>

<pre><code class="r">require(caret)
confusionMatrix(cft, positive = "1")
</code></pre>

<pre><code class="r">confusionMatrix(pred.class, ROCR.simple$labels, positive = "1")
</code></pre>

<pre><code>## Confusion Matrix and Statistics
## 
##           Reference
## Prediction  0  1
##          0 91 14
##          1 16 79
##                                         
##                Accuracy : 0.85          
##                  95% CI : (0.793, 0.896)
##     No Information Rate : 0.535         
##     P-Value [Acc &gt; NIR] : &lt;2e-16        
##                                         
##                   Kappa : 0.699         
##  Mcnemar's Test P-Value : 0.855         
##                                         
##             Sensitivity : 0.849         
##             Specificity : 0.850         
##          Pos Pred Value : 0.832         
##          Neg Pred Value : 0.867         
##              Prevalence : 0.465         
##          Detection Rate : 0.395         
##    Detection Prevalence : 0.475         
##       Balanced Accuracy : 0.850         
##                                         
##        'Positive' Class : 1             
## 
</code></pre>

<h1 id="section-1">三、混淆矩阵的缺点</h1>

<h2 id="section-2">1 需要自己确定阀值</h2>

<p>可以看到，混淆矩阵4个值的确定都依赖于最直线我们主观设定的0.5。如果只依靠混淆矩阵这种原始的方法，那么不经过繁琐的试错我们无法确认哪个阀值是最好的。</p>

<h2 id="section-3">2不平衡数据鲁棒性不好</h2>

<p>一些positive事件发生概率极小的不平衡数据集(imbalanced data),混淆矩阵可能效果不好。比如对信用卡交易是否异常做分类的情形，很可能1w笔交易中只有1笔交易是异常的。一个将将所有交易都判定为正常的分类器，准确率是99.99%。这个数字虽然很高，但是没有任何现实意义。</p>

<p>在之前列举的各种分类模型评价方法中，收益图(Gain Chart)、提升图(Lift Chart)、KS图(KS Chart)、接受者操作特性曲线(ROC Chart)都对混淆矩阵的缺点的有改进。参考后续。</p>

</article>
<p class="lotus-anno">声明: 本文采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/" rel="nofollow" target="_blank" title="自由转载-非商用-非衍生-保持署名">BY-NC-SA</a> 授权。转载请注明转自: <a href="" title="" rel="nofollow">CCM</a></p>
<section class="lotus-nextpage fn-clear">
    
    <div class="lotus-nextpage-left"><a class="prev" href="/generate-dummy-variable-in-r-language/" rel="prev">&laquo;&nbsp;R语言中生成虚拟变量/哑变量</a></div>
    
    
    <div class="lotus-nextpage-right"><a class="next" href="/ted-lessons-what-is-an-algorithm/" rel="next">TED lessons 什么是算法&nbsp;&raquo;</a></div>
    
</section>


<footer class="lotus-footer">
	<p>Copyright © 2014 数据科学与统计学习 All rights reserved.</p>
</footer>
<script src="http://localhost:4000/static/js/jquery.scrollTo.js" type="text/javascript"></script>
<script src="http://localhost:4000/static/js/iLotus.js" type="text/javascript"></script>
</body>
</html>